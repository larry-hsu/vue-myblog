-- phpMyAdmin SQL Dump
-- version 4.9.2
-- https://www.phpmyadmin.net/
--
-- 主机： localhost
-- 生成日期： 2020-04-28 11:34:57
-- 服务器版本： 8.0.18
-- PHP 版本： 7.3.12

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- 数据库： `websites`
--

-- --------------------------------------------------------

--
-- 表的结构 `articles`
--

CREATE TABLE `articles` (
  `id` int(6) NOT NULL,
  `articleName` varchar(255) NOT NULL,
  `postTime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `author` varchar(255) NOT NULL,
  `content` text NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `articles`
--

INSERT INTO `articles` (`id`, `articleName`, `postTime`, `author`, `content`) VALUES
(52, '四维', '2020-03-02 08:21:07', 'larry·hsu', '我们想象，假如有一种纯二维空间的生物，就好像平面上的一幅画一样。它们能感受到什么呢？ \r\n<br>\r\n<br>它们只能感受到正方形啊、三角形啊这些平面图形，它们永远感受不到立体。 \r\n<br>\r\n<br>我们去看它们就觉得很可怜了，我们这世界中的一切它们都不可能理解，连这世界的存在它们都不知道。&nbsp;<br>&nbsp;\r\n<br>那么，会不会有一种四维空间的生物，觉得我们这些人类生活在三维空间，永远不能体验到四维空间也是一件很可怜的事呢？ \r\n<br>  \r\n<br>挺好奇的，是吧？ \r\n<br>\r\n<br>其实我们有办法间接体验四维空间。 \r\n<br>\r\n<br>假设有一个二维空间的生物代号为 A，它只能理解二维的平面图形。 \r\n<br>\r\n<br>我们可以给它所生活的平面加入一个时间的维度，给它凑成三维。比如说，我们有一个正方体想要让 A体会，那么我们可以让这个正方体慢慢穿过 A所在的平面。 \r\n<br>\r\n<br>这时， A只能看到正方体和平面重合部分的二维图形，但这个二维图形是在随时间不断变化的。（除非这个正方体的一面和 A所在的平面平行，并且正方体按照垂直于 A所在平面的方向穿过。那么 A就只能看到它的世界里突然出现了一个正方形，过了一会儿又突然消失了。所以别这么干，给正方体找个“怪”一点的角度）。 \r\n<br>\r\n<br>虽然 A仍旧不能想象三维世界是什么样子的，但是通过这种形式，可以让它间接感受到三维正方体。当然，正方体通过平面的角度和速度不同， A所体验到的那个不断变换的二维图形也是不同的。 \r\n<br>\r\n<br>同样的办法，我们也可以让一些四维图形来通过我们的空间。我们看到的是一些不断变幻的三维图形，这就是四维图形在我们世界中的投影。<br>'),
(53, '浮生若梦 为欢几何', '2019-10-23 16:00:00', 'larry·hsu', ' <div>书店里瞥到《浮生六记》这本书的时候，不知觉间就想到了这句话：</div><div><br></div><blockquote>夫天地者，万物之逆旅也，光阴者，百代之过客也，而浮生若梦，为欢几何。</blockquote><div><br></div><div>古人的婚姻到老大多最后都是相视如仇，少有恩爱到白头的，所以也有“恩爱不到头”的说法。像沈复这样能和妻子耳鬓相磨，亲同形影的人着实不多，他们恩爱一生，可谓是古今传奇。\r\n\r\n \r\n\r\n&nbsp;</div><div><br></div><div>然而读完全篇之后我不禁要问我自己，沈复和芸娘确实是真爱吗？他到底是一个情痴还是渣男呢？既然他深爱着妻子，为什么又能毫无愧疚的和同伴狎妓风流呢？在芸娘死后又能突破自己当时许下的原则再续弦呢？\r\n\r\n \r\n\r\n&nbsp;</div><div><br></div><div>芸娘的性格温婉宽和，风雅感性，有着江南水乡不可多得的韵味。林语堂先生说芸是“中国文学中一个最可爱的人”。诚非过誉、在读完全本后，我不禁会有“沈复怎么也配不上芸娘”的念头。</div><div><br></div><div>芸娘临死的时候对沈复言：“愿君另续的德荣兼备者，以奉双亲，抚我遗子，妾亦瞑目矣。”\r\n\r\n \r\n\r\n沈复毫不犹豫的回到：“卿果中道相舍，断无再续之理，况且‘曾经沧海难为水，除却巫山不是云’耳”。芸娘刚死时，他自己也道“当是时，孤灯一盏，举目无亲，两手空拳，寸心欲碎。绵绵此恨，曷有其极”。回头却好像又忘了这茬，朋友“琢堂闻之，亦为之浩叹，赠予一妾，重入春梦。从此扰扰攘攘，又不知梦醒何时耳。”据传这个女子就是华宛如。后来还有沈复和她的一段故事，但暂时不为人知。\r\n\r\n\r\n但你要说他不爱芸娘的话，却也说不通。他能怂恿芸娘女扮男装和他一起去逛庙会，还因为芸娘盯着一个少妇小姑娘看，差点没有打起来。看到这里的时候，我这条被虐了千百遍的单身狗又承受了一次生命不能承受之重。&nbsp;</div><div><br></div><div>&nbsp;这件事情在今天确实是稀松平常，而且女子根本就不用女扮男装，就这样堂堂正正的走在大马路上，还不忘露着自己的大白腿。可是在封建礼教大防的清代，女子随便出街万一出什么事情，流言碎语就会接踵而来，这无声的力量就足以杀死任何一个当时的良家女子。与沈复到太湖的时候，芸娘言：“此即所谓太湖耶？今得见天地之宽，不虚此生矣！想闺中人有终身不能见此者！”由此可见当时社会的意识形态就是女子应该在家中大门不出二门不迈。沈复能无视这些，足矣说明他对芸娘的爱之深。芸生病血疾大发时，沈复时已薪水不继，他去寻求朋友的帮助，因为害怕芸娘挂念，他“佯为雇骡以安其心，实则襄饼徒步，且食且行”。晚上没地方住，只好住在土地庙里面“得一土地祠，高约五尺，环以短墙……于是移小石于旁，以身探之，仅容半体。以风帽反戴掩面，坐半身于中，出膝在外，闭目静听，风萧萧而已。”这实际上就相当于野外露营了。现代一般人尚且做不到，可况他呢？&nbsp; &nbsp; &nbsp;&nbsp;</div><div><br></div><div>在我看来，他超越了时代一点点，正是超出的一点点缔造了沈复和芸娘的传奇故事。不过也就超出了一点点而已。这也就不难解释他那些看似矛盾的举动了。正是源于此，他的意识也不可能立即达到和我们现在人一样的高度，和现在人一样讲究着“一夫一妻”，他终归要受到当时社会的意识形态的影响。就比如说当时他和同伴狎妓风流的举动放到今天就像我们去KTV唱歌一样稀松平常。所以当时的人是不会觉得有什么不对的地方的。&nbsp;</div><div><br></div><div>封建时代的意识形态的是什么呢？从古到今的文人都非常喜欢文人才子，名妓风流的故事，也非常喜欢写这些故事，不然也不会有柳如是、苏小小、李师师、陈圆圆的传奇女子的故事流传至今了。</div><div><br></div><div>对于文人才子来说，再也没有像红颜知己，红袖添香什么的能够使得他们感受到最大的快活了。在那个男尊女卑的时代，沈复对他的妻子可谓是极好了。所以沈复深爱者芸娘的另一个理由也就自然而然了，便是他深深的坚信着她就是自己的红颜知己，事实也是如此。芸娘身为一个父亲早丧、独自靠女红养活一家、自学认字的才女，能通文辞，善解语和通情达理，沈复很喜欢她的一点便是能陪自己在闺房中谈诗论书、说古道今、赏月饮酒。这样的女子又怎么能不惹人怜爱呢？&nbsp;</div>'),
(55, '跨域资源共享 CORS 详解', '2020-03-03 16:00:00', '阮一峰', ' <div>CORS是一个W3C标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。\r\n\r\n&nbsp;</div><div>它允许浏览器向跨源服务器，发出<font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">XMLHttpRequest</span></font>请求，从而克服了AJAX只能同源使用的限制。\r\n\r\n&nbsp;</div><div>本文详细介绍CORS的内部机制。<br></div><div><br></div><h2>一、简介</h2><div><hr id=\"null\"></div><div>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。&nbsp; &nbsp;</div><div>整个CORS通信过程，都是浏览器自动完成，不需要用户的参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</div><div>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</div><div><br></div><h2>二、两种请求</h2><div><hr id=\"null\"></div><div>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\r\n\r\n&nbsp;</div><div>只要同时满足以下两大条件，就属于简单请求。</div><blockquote>1) 请求方法是以下三种方法之一：\r\n\r\n&nbsp;<br><ul><li>HEAD\r\n&nbsp;</li><li>GET\r\n&nbsp;</li><li>POST\r\n&nbsp;</li></ul>2）HTTP的头信息不超出以下几种字段：\r\n\r\n&nbsp;<br><ul><li>Accept\r\n&nbsp;</li><li>Accept-Language\r\n&nbsp;</li><li>Content-Language\r\n&nbsp;</li><li>Last-Event-ID\r\n&nbsp;</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></blockquote><div><br></div><div>凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。<br></div><div><br></div><h2>三、简单请求</h2><div><hr id=\"null\"></div><h4>3.1 基本流程</h4><div><hr id=\"null\"></div><div>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Origin</span></font>字段。\r\n\r\n&nbsp;</div><div>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Origin</span></font>字段。</div><blockquote>GET /cors HTTP/1.1\r\n&nbsp;<br>Origin: http://api.bob.com\r\n&nbsp;<br>Host: api.alice.com\r\n&nbsp;<br>Accept-Language: en-US\r\n&nbsp;<br>Connection: keep-alive\r\n&nbsp;<br>User-Agent: Mozilla/5.0...</blockquote><div><br></div><div>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。&nbsp; &nbsp;</div><div>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Origin</span>字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。&nbsp;</div><div>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</div><blockquote>Access-Control-Allow-Origin: http://api.bob.com\r\n&nbsp;<br>Access-Control-Allow-Credentials: true\r\n&nbsp;<br>Access-Control-Expose-Headers: FooBar\r\n&nbsp;<br>Content-Type: text/html; charset=utf-8</blockquote><div><br></div><div>上面的头信息之中，有三个与CORS请求相关的字段，都以<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-</span></font>开头。&nbsp; &nbsp;</div><div><b>1）</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Origin\r\n</span><b>\r\n&nbsp;</b></div><div>该字段是必须的。它的值要么是请求时<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Origin</span></font>字段的值，要么是一个<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">*</span></font>，即表示接受任意域名的请求。&nbsp; &nbsp;</div><div><b>2）</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Credentials</span><b>\r\n\r\n&nbsp;</b></div><div>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">true</span></font>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">true</span></font>，如果服务器不要浏览器发送Cookie，删除该字段即可。&nbsp; &nbsp;</div><div><b>3）</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Expose-Headers</span><b>\r\n\r\n&nbsp;</b></div><div>该字段可选。CORS请求时，<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">XMLHttpRequest</span></font>对象的<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">getResponseHeader()</span></font>方法只能拿到6个基本字段：<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Cache-Control</span></font>、<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Content-Language</span><b>、</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Content-Type</span><b>、</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Expires</span><b>、</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Last-Modified</span><b>、</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Pragma</span></font>。如果想拿到其他字段，就必须在<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Expose-Headers</span></font>里面指定。上面的例子指定，<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">getResponseHeader(\'FooBar\')</span></font>可以返回<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">FooBar</span></font>字段的值。</div><div><br></div><h4>3.2 withCredentials 属性</h4><div><hr id=\"null\"></div><div>上面说到，CORS 请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定<span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Credentials</span>字段。</div><blockquote>Access-Control-Allow-Credentials: true</blockquote><div><br></div><div>另一方面，开发者必须在AJAX请求中打开<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">withCredentials</span></font>属性。</div><blockquote>var xhr = new XMLHttpRequest();\r\n&nbsp;<br>xhr.withCredentials = true;</blockquote><div><br></div><div>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。\r\n\r\n&nbsp;</div><div>但是，如果省略<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">withCredentials</span></font>设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭<font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">withCredentials</span></font>。</div><blockquote>xhr.withCredentials = false;</blockquote><div><br></div><div>需要注意的是，如果要发送Cookie，<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Origin</span></font>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">document.cookie</span></font>也无法读取服务器域名下的Cookie。<br></div><h2><br>四、非简单请求</h2><div><hr id=\"null\"></div><h4>4.1 预检请求</h4><div>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者Content-Type字段的类型是<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">application/json</span></font>。&nbsp; &nbsp;</div><div>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。&nbsp; &nbsp;</div><div>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">XMLHttpRequest</span></font>请求，否则就报错。\r\n\r\n下面是一段浏览器的JavaScript脚本。</div><blockquote>var url = \'http://api.alice.com/cors\';\r\n&nbsp;<br>var xhr = new XMLHttpRequest();\r\n&nbsp;<br>xhr.open(\'PUT\', url, true);\r\n&nbsp;<br>xhr.setRequestHeader(\'X-Custom-Header\', \'value\');\r\n&nbsp;<br>xhr.send();</blockquote><div><br></div><div>上面代码中，HTTP请求的方法是<b><font color=\"#243c4f\">PUT</font></b>，并且发送一个自定义头信息<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">X-Custom-Header</span></font>。&nbsp; &nbsp;</div><div>浏览器发现，这是一个非简单请求，就自动发出一个\"预检\"请求，要求服务器确认可以这样请求。下面是这个\"预检\"请求的 HTTP头信息。</div><blockquote>OPTIONS /cors HTTP/1.1\r\n&nbsp;<br>Origin: http://api.bob.com\r\n&nbsp;<br>Access-Control-Request-Method: PUT\r\n&nbsp;<br>Access-Control-Request-Headers: X-Custom-Header\r\n&nbsp;<br>Host: api.alice.com\r\n&nbsp;<br>Accept-Language: en-US\r\n&nbsp;<br>Connection: keep-alive\r\n&nbsp;<br>User-Agent: Mozilla/5.0...</blockquote><div><br></div><div>\"预检\"请求用的请求方法是<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">OPTIONS</span></font>，表示这个请求是用来询问的。头信息里面，关键字段是<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Origin</span></font>，表示请求来自哪个源。\r\n\r\n除了<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Origin</span></font>字段，\"预检\"请求的头信息包括两个特殊字段。</div><div><b>1）</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Request-Method\r\n</span><b>\r\n&nbsp;</b></div><div>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">PUT</span></font>。&nbsp;&nbsp;</div><div><b>2）</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Request-Headers&nbsp; </span><b>&nbsp;</b></div><div>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">X-Custom-Header</span></font>。<br></div><div><br></div><h4>4.2 预检请求的回应</h4><div><hr id=\"null\"></div><div>服务器收到\"预检\"请求以后，检查了<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Origin</span></font>、<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Request-Method</span></font>和<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Request-Headers</span></font>字段以后，确认允许跨源请求，就可以做出回应。</div><blockquote>HTTP/1.1 200 OK\r\n&nbsp;<br>Date: Mon, 01 Dec 2008 01:15:39 GMT\r\n&nbsp;<br>Server: Apache/2.0.61 (Unix)\r\n&nbsp;<br>Access-Control-Allow-Origin: http://api.bob.com\r\n&nbsp;<br>Access-Control-Allow-Methods: GET, POST, PUT\r\n&nbsp;<br>Access-Control-Allow-Headers: X-Custom-Header\r\n&nbsp;<br>Content-Type: text/html; charset=utf-8\r\n&nbsp;<br>Content-Encoding: gzip\r\nContent-Length: 0\r\n&nbsp;<br>Keep-Alive: timeout=2, max=100\r\n&nbsp;<br>Connection: Keep-Alive\r\n&nbsp;<br>Content-Type: text/plain</blockquote><div><br></div><div>上面的HTTP回应中，关键的是<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Origin</span></font>字段，表示<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">http://api.bob.com</span></font>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</div><blockquote>Access-Control-Allow-Origin: *</blockquote><div><br></div><div>如果浏览器否定了\"预检\"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">XMLHttpRequest</span></font>对象的<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">onerror</span></font>回调函数捕获。控制台会打印出如下的报错信息。</div><blockquote>XMLHttpRequest cannot load http://api.alice.com.\r\n&nbsp;<br>Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</blockquote><div><br></div><div>服务器回应的其他CORS相关字段如下。</div><blockquote>Access-Control-Allow-Methods: GET, POST, PUT\r\n&nbsp;<br>Access-Control-Allow-Headers: X-Custom-Header\r\n&nbsp;<br>Access-Control-Allow-Credentials: true\r\n&nbsp;<br>Access-Control-Max-Age: 1728000</blockquote><div><br></div><div><b>1）</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Methods</span><b>\r\n\r\n&nbsp;</b></div><div>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求。&nbsp; &nbsp;</div><div><b>2）</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Headers</span><b>\r\n\r\n&nbsp;</b></div><div>如果浏览器请求包括<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Request-Headers</span></font>字段，则<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Headers</span></font>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段。&nbsp; &nbsp;</div><div><b>3）</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Credentials</span><b>\r\n\r\n&nbsp;</b></div><div>该字段与简单请求时的含义相同。&nbsp; &nbsp;</div><div><b>4）</b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Max-Age</span><b>\r\n\r\n&nbsp;</b></div><div>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。<br></div><div><br></div><h4>4.3 浏览器的正常请求和回应</h4><div><hr id=\"null\"></div><div>一旦服务器通过了\"预检\"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Origin</span></font>头信息字段。\r\n\r\n&nbsp;</div><div>下面是\"预检\"请求之后，浏览器的正常CORS请求。</div><blockquote>PUT /cors HTTP/1.1\r\n&nbsp;<br>Origin: http://api.bob.com\r\n&nbsp;<br>Host: api.alice.com\r\n&nbsp;<br>X-Custom-Header: value\r\n&nbsp;<br>Accept-Language: en-US\r\n&nbsp;<br>Connection: keep-alive\r\n&nbsp;<br>User-Agent: Mozilla/5.0...</blockquote><div><br></div><div>上面头信息的<b><font color=\"#243c4f\">Origin</font></b>字段是浏览器自动添加的。\r\n\r\n&nbsp;</div><div>下面是服务器正常的回应。</div><blockquote>Access-Control-Allow-Origin: http://api.bob.com\r\n&nbsp;<br>Content-Type: text/html; charset=utf-8</blockquote><div><br></div><div>上面头信息中，<font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Access-Control-Allow-Origin</span></font>字段是每次回应都必定包含的。<br></div><div><br></div><h2>五、与JSONP的比较</h2><div><hr id=\"null\"></div><div>CORS与JSONP的使用目的相同，但是比JSONP更强大。\r\n\r\n&nbsp;</div><div>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。&nbsp; &nbsp;</div><div>（完）<br></div>'),
(57, '有趣的问题', '2020-03-09 11:56:04', 'larry·hsu', ' <div>这段时间在找实习，做了一些笔试题，写篇文章记录下解决过程，时间久了以后也不怕忘了。\r\n\r\n\r\n\r\n&nbsp;</div><div><br></div><h2>1、最少步数移动到最后一个节点</h2><div><hr id=\"null\"></div><div>题目的描述：\r\n\r\n给定一个数组，里面全部是正整数。其数字大小表示这一步最多可以向后移动几个节点。总是从数组第一个元素开始移动。请问如何移动，可以以最少步数移动到最后一个节点。\r\n\r\n\r\n&nbsp;</div><div>补充说明：给定数据是[3,4,2,1,3,1]。 初始状态指向3，表示下一步可以移动1格 或者 2格 或者3格。并能正确通过以下测试用例：</div><blockquote>console.log(solve([4, 4, 9, 1, 3, 1, 8, 5])); //[4, 9, 5]\r\n&nbsp;<br>console.log(solve([1, 3, 4, 2, 1, 1]));&nbsp; //[1, 3, 4, 1]</blockquote><div><br></div><h4>思路</h4>在找到最大值后记录下最大值在数组中的位置，同时将这个最大值与数组的最后一个元素进行比较如果相等就结束循环，如果不相等则判断最大值在当前在数组中的位置再加上最大值后是否超越了数组的长度，如果超越了数组的长度，则记录下数组的最后一个元素后结束循环。最后再控制好循环的条件就可以了。<div><br><blockquote>function solve(arr) {&nbsp;</blockquote><blockquote>&nbsp; &nbsp; let len = arr.length;  // 数组的长度&nbsp;</blockquote><blockquote>&nbsp; &nbsp; let maxPos = 0;  // 最大值的位置</blockquote><blockquote>&nbsp; &nbsp; let path = [arr[0]];  // 记录经过的节点</blockquote><blockquote>&nbsp; &nbsp; let lastVal = arr[len - 1];  // 数组的最后一个数</blockquote><blockquote>&nbsp; &nbsp; let pos, posVal, maxVal;  // 初始化一些变量&nbsp;</blockquote><blockquote><br></blockquote><blockquote>&nbsp; &nbsp; while (true) {&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; maxVal = 0;  // 因为数组是正整数，所以0比任何一个数都小</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; pos = maxPos;&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; posVal = arr[pos];&nbsp;</blockquote><blockquote><br></blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; for (let i = pos + 1; i &lt;= posVal + pos; i++) {</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (arr[i] &gt; maxVal) {&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxVal = arr[i];  // 找到的最大值&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxPos = i;  // 记录下最大值的位置&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;</blockquote><blockquote><br></blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; path.push(maxVal);&nbsp;</blockquote><blockquote><br></blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; if (maxVal === lastVal) break;  // 正好到了数组的最后一个数&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; else if (maxPos + maxVal &gt; len - 1) {&nbsp; // 直接超越了数组&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path.push(lastVal);  // 将最后一个数压入数组中&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;</blockquote><blockquote>&nbsp; &nbsp; }&nbsp;</blockquote><blockquote><br></blockquote><blockquote>&nbsp; &nbsp; return path;</blockquote><blockquote>｝</blockquote></div><div><br></div><div>上面的代码中，for循环中的条件设置时比较重要，变量i总是从当前位置的下一个位置开始，到当前位置加上数组当前位置上的数值。在循环中找到下一个最大值再记录下来。</div><div><br></div><h4>测试</h4><div><br></div><blockquote>console.log(solve([3, 4, 2, 1, 3, 1, 4, 6]));&nbsp; // [3, 4, 3, 6]\r\n&nbsp;<br>console.log(solve([4, 4, 9, 1, 3, 1, 8, 5]));&nbsp; // [4, 9, 5]\r\n&nbsp;<br>console.log(solve([1, 3, 4, 2, 1, 1]));&nbsp; // [1, 3, 4, 1]</blockquote><div><br></div><div><br></div><div><br></div>'),
(58, '浏览器渲染机制', '2020-03-11 10:57:53', 'larry·hsu', ' <div>浏览器解析渲染页面分为一下五个步骤：\r\n\r\n&nbsp;</div><blockquote><ul><li>根据 HTML 解析出 DOM 树\r\n \r\n \r\n&nbsp;</li><li>根据 CSS 解析生成CSSOM树</li><li>结合 DOM 树和 CSS 规则树，生成渲染树\r\n \r\n \r\n&nbsp;</li><li>Layout(回流): 根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）<br></li><li>Painting(重绘): 根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>根据计算好的信息绘制页面</li></ul></blockquote><div><br></div><h4>根据 HTML 解析 DOM 树</h4><div><hr id=\"null\"></div><div>浏览器把得到的html代码转换为一个DOM树，html文档中的每一个tag标签都是一个DOM树的节点，DOM树的根节点是document对象。需要注意的是，使用js动态生成的DOM节点也在DOM树上。</div><div>DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。&nbsp;</div><div><br></div><h4>根据 CSS 解析生成 CSS 规则树</h4><div></div><div><hr id=\"null\">浏览器会把所有的样式解析为样式结构体（包括css样式和浏览器默认样式），浏览器识别不了的样式不能解析，最后生成了CSSOM树。需要注意的是：<br></div><div><blockquote><ul><li>解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。</li><li>浏览器在 CSS 规则树生成之前不会进行渲染。\r\n\r\n</li></ul></blockquote></div><div><br></div><h4>将DOM 树和 CSS 规则树合并，生成渲染树</h4><div><hr id=\"null\"></div><div>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树\r\n 。精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</div><div>为了构建渲染树，浏览器主要完成了以下工作：<br></div><blockquote><ul><li>从DOM树的根节点开始遍历每个<font color=\"#243c4f\"><b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">可见</span></b></font>节点。\r\n&nbsp;</li><li>有些节点是不可见的（例如，脚本标记、meta标记等），由于它们不反映在渲染输出中，因此被省略。<br></li><li>有些通过CSS隐藏节点也会被忽略。<br></li><li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。\r\n&nbsp;</li><li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li></ul></blockquote><div><br></div><div>DOM节点包括可见节点和不可见节点，像div，p等这种结构性的标签节点可被称为可见节点，而 script、meta 等这种在页面上显示不出来的节点则被称为不可见节点。包括一些通过css进行隐藏的节点也是可见节点，比如</div><blockquote><ul><li>display: none</li><li>visibility: hidden</li><li>opacity: 0</li></ul></blockquote><div>也会显示在渲染树上，只有<b><font color=\"#243c4f\">display:none</font></b>的节点才不会显示在渲染树上。<b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">而渲染树只包含可见节点</span>。</font></b></div><div><br></div><h4>根据渲染树计算每一个节点的信息（布局）</h4><div><hr id=\"null\"><br></div><blockquote><ul><li>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸</li><li>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li></ul></blockquote><div><br></div><div><font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">回流</span></font></div><div>通过构造渲染树，可以将可见节点以及对应的样式结合起来后，还需要知道这个节点在浏览器视口中的位置，计算节点位置的过程就是回流。</div><div>浏览器从渲染树的根节点开始遍历，计算出每个节点在浏览器中的确切大小和位置。</div><div><font color=\"#243c4f\" style=\"\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">重绘</span></font></div><div>通过构造渲染树和回流阶段，浏览器知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，此时，浏览器就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</div><div><br></div><h4>根据计算好的信息绘制页面</h4><hr id=\"null\"><br><div>绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上，根据background, border, box-shadow等样式和HTML内容，将Layout生成的区域填充为最终将显示在屏幕上的像素。最后将信息渲染到屏幕中每一个真实的像素点。<br></div><div>在此过程中，某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。但是如果某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</div><div><br></div><h4>HTML页面加载和解析流程</h4><hr id=\"null\"><br>最后，总结下HTML页面加载和解析流程。<div><br><blockquote><ul><li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；&nbsp;</li><li>浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；&nbsp;</li><li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件；&nbsp;</li><li>浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；&nbsp;</li><li>浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；&nbsp;</li><li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；&nbsp;</li><li>浏览器发现了一个包含一行 Javascript 代码的＜script＞标签，赶快运行它；&nbsp;</li><li>Javascript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码；&nbsp;</li><li>终于等到了＜/html＞的到来，浏览器泪流满面……&nbsp;</li><li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript 让浏览器换了一下＜link＞标签的CSS路径；&nbsp;</li><li>浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。&nbsp;</li></ul></blockquote><div><br></div><h4>参考链接</h4><hr id=\"null\"><div><br></div><div><blockquote>https://www.jianshu.com/p/a9c4640c188e<br>https://zhuanlan.zhihu.com/p/52076790</blockquote><div><br></div></div></div>'),
(59, '浏览器事件循环机制', '2020-03-11 12:23:06', 'larry·hsu', ' <h4>来源</h4><hr id=\"null\"><div> JavaScript 是一门单线程的语言，这也意味着 JS 无法进行多线程编程。这是因为 javascript 要和浏览器进行交互，所以从一开始它就被设计成了一门单线程非阻塞的脚本语言。<br></div><blockquote><ul><li>单线程：任何时候，都只有一个主线程来处理所有的逻辑任务。&nbsp;</li><li>非阻塞：主线程不会直接处理异步任务，而是当它们返回结果之后再去处理，因为异步操作往往具有不确定性，会阻塞浏览器的渲染。 常用的，例如 ajax 请求、setTimeout、promise 都是异步操作\r\n。</li></ul></blockquote><div><br></div><div>在使用 ajax 进行通信的时候，默认了它是异步的，但是如果设置其为同步执行，会发生什么？如果写一个小的测试程序，将后台代码延迟5s，就会发现浏览器会出现阻塞，直到 ajax 响应了之后才会正常运行。这便是异步模式要解决的首要问题，如何使浏览器非阻塞的运行任务。想象一下如果同步的执行 ajax 请求的话，那么浏览器等待的时间是一个未知数，在网络通信中可能很快也可能很慢，也可能永远也不会响应，这也就会导致浏览器会阻塞在一个未知的任务上面，这也是不希望看到的。所以便希望有一种方式能够异步的处理程序，使得浏览器并不需要关心一个 ajax 请求会在何时完成，甚至它可以永远不会响应，只需要知道在请求响应后该如何处理，并且在等待响应的这段时间内还可以做一些其他的工作。因此，便有了 JavaScript Event Loop。<br></div><div><br></div><h4>事件队列</h4><hr id=\"null\">先来看一段简单的代码：<div><br><blockquote>console.log(\"script start\");\r\n\r\n&nbsp;</blockquote><blockquote><br></blockquote><blockquote>setTimeout(function () {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp;console.log(\"setTimeout\");\r\n&nbsp;</blockquote><blockquote>}, 1000);\r\n\r\n&nbsp;</blockquote><blockquote><br></blockquote><blockquote>console.log(\"script end\");<br></blockquote><br><div>其对应的输出为：</div><blockquote>script start\r\n&nbsp;</blockquote><blockquote>script end  \r\n&nbsp;</blockquote><blockquote>setTimeout<br></blockquote><div><br></div><div>首先，程序输出 \'script start\' 和 \'script end\'，在大约1s之后输出了 \'setTimeout\'。该程序的 \'script end\' 并没有等待1s之后输出，而是立即输出。这是因为 setTimeout 是一个异步的函数。意思也就是说在设置一个延迟函数后，当前脚本并不会阻塞，它只是会在浏览器的<b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">事件表</span></font></b>中进行记录，程序会继续向下执行。当延迟的时间结束之后，事件表会将回调函数添加至<b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">事件队列</span></font></b>（task queue）中，事件队列拿到了任务过后便将任务压入<b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">执行栈（stack）</span></font></b>当中，执行栈执行任务，输出 \'setTimeout\'。<br></div><div>事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。<br></div><div>即使将上述代码中的延迟时间设置为0，\'setTimeout\' 总是会在 \'script end\' 之后输出。这是因为 setTimeout 的回调函数只是会被添加至事件队列，而不是立即执行。由于当前的任务没有执行结束，所以 setTimeout 任务不会执行，直到输出了 \'script end\' 之后，当前任务执行完毕，执行栈为空，这时事件队列才会把 setTimeout 回调函数压入执行栈执行。<br></div><div><br></div><h4>事件循环</h4><div><hr id=\"null\"></div><div>由于 JS 是单线程的，同步执行任务会造成浏览器的阻塞，所以将 JS 分成一个又一个的任务，通过不停的循环来执行事件队列中的任务。这就使得浏览器在挂起某一个任务的时候可以去做一些其他的事情，而不需要等待这个任务执行完毕。所以事件循环的运行机制大致分为以下步骤：<br></div><blockquote><ul><li>同步和异步任务分别进入不同的执行场所，同步的进入主线程，异步的进入Event Table并注册函数。&nbsp;</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue，也就是注册回调函数。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。&nbsp;</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。&nbsp;&nbsp;</li></ul></blockquote><div><br></div><div>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。<br></div><div><br></div><h4>宏任务和微任务</h4><div></div><div><hr id=\"null\"></div><div>事件队列主要有宏任务队列和微任务队列。<br></div><div>可以有一个或多个 task 队列，例如：</div><blockquote><ul><li>script（全局任务，每一个js文件也是一个宏任务）</li><li>setTimeout,&nbsp;</li><li>setInterval,&nbsp;</li><li>I/O,&nbsp;</li><li>UI&nbsp;</li><li>rendering</li><li>setImmediate（属于nodeJS ）。</li></ul></blockquote><div><br></div><div>但是只有一个 microtask 队列，例如：</div><blockquote><ul><li>Promise</li><li>Object.observer</li><li>MutationObserver</li><li>process.nextTick（属于 nodeJS ）</li></ul></blockquote><div><br></div><div>先来看一段代码，猜猜它将会以何种顺序输出：<br></div><blockquote>console.log(\'script start\');\r\n\r\n&nbsp;</blockquote><blockquote><br></blockquote><blockquote>setTimeout(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; console.log(\'setTimeout\');\r\n&nbsp;</blockquote><blockquote>}, 0);\r\n\r\n&nbsp;</blockquote><blockquote><br></blockquote><blockquote>Promise.resolve().then(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; console.log(\'promise1\');\r\n&nbsp;</blockquote><blockquote>}).then(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; console.log(\'promise2\');\r\n&nbsp;</blockquote><blockquote>});\r\n\r\n&nbsp;</blockquote><blockquote><br></blockquote><blockquote>console.log(\'script end\');</blockquote><div><br></div><div>其对应的输出为：</div><blockquote>script start\r\n&nbsp;</blockquote><blockquote>script end\r\n&nbsp;</blockquote><blockquote>promise1\r\n&nbsp;</blockquote><blockquote>promise2\r\n&nbsp;</blockquote><blockquote>setTimeout<br></blockquote><div><br></div><div>要理解上面代码的输出原理，就需要了解 JavaScript 的 event loop 是如何处理 tasks 以及 microtasks&nbsp;的。<br></div><div>每一个\'线程\'都有一个独立的 event loop，每一个 <b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">web worker</span></font></b> 也有一个独立的 event loop，所以它可以独立的运行。如果不是这样的话，那么所有的窗口都将共享一个 event loop，即使它们可以同步的通信。</div><div>event loop 将会持续不断的，有序的执行队列中的任务（tasks）。每一个 event loop 都有着众多不同的任务来源，这些任务来源能够保证其中的 task 能够有序的执行（参见标准 Indexed Database API 2.0）。不过，在每一轮事件循环结束之后，浏览器可以自行选择将哪一个 source 当中的 task 加入到执行队列当中。这样也就使得了浏览器可以优先选择那些敏感性的任务，例如用户的的输入。<br></div><div><b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Task</span></font></b> 是严格按照时间顺序压栈和执行的，所以浏览器能够使得 JavaScript 内部任务与 DOM 任务能够有序的执行。当一个 task 执行结束后，在下一个 task 执行开始前，浏览器可以对页面进行重新渲染。每一个 task 都是需要分配的，例如从用户的点击操作到一个点击事件，渲染HTML文档，同时还有上面例子中的 setTimeout。\r\n\r\n　　</div><div>setTimeout 的工作原理相信大家应该都知道，其中的延迟并不是完全精确的，这是因为 setTimeout 它会在延迟时间结束后分配一个新的 task 至 event loop 中，而不是立即执行，所以 setTimeout 的回调函数会等待前面的 task 都执行结束后再运行。这就是为什么 \'setTimeout\' 会输出在 \'script end\' 之后，因为 \'script end\' 是第一个 task 的其中一部分，而 \'setTimeout\' 则是一个新的 task。这里先解释了 event loop 的基本原理，接下来会通过这个例子来讲解 microtask 的工作原理。<br></div><div><b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Microtask</span></font></b> 通常来说就是需要在当前 task 执行结束后立即执行的任务，例如需要对一系列的任务做出回应，或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。microtask 任务队列是一个与 task 任务队列相互独立的队列，microtask 任务将会在每一个 task 任务执行结束之后执行。每一个 task 中产生的 microtask 都将会添加到 microtask 队列中，microtask 中产生的 microtask 将会添加至当前队列的尾部，并且 microtask 会按序的处理完队列中的所有任务。microtask 类型的任务目前包括了 MutationObserver 以及 Promise 的回调函数。<br></div><div>每当一个 Promise 被决议（或是被拒绝），便会将其回调函数添加至 microtask 任务队列中作为一个新的 microtask 。这也保证了 Promise 可以异步的执行。所以当我们调用 .then(resolve, reject) 的时候，会立即生成一个新的 microtask 添加至队列中，这就是为什么上面的 \'promise1\' 和 \'promise2\' 会输出在 \'script end\' 之后，因为 microtask 任务队列中的任务必须等待当前 task 执行结束后再执行，而 \'promise1\' 和 \'promise2\' 输出在 \'setTimeout\' 之前，这是因为 \'setTimeout\' 是一个新的 task，而 microtask 执行在当前 task 结束之后，下一个 task 开始之前。</div><blockquote>注：<b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">web worker</span>，</font></b>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。\r\n\r\n\r\n\r\nWorker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</blockquote><div><br></div><h4>最后</h4><div></div><div><hr id=\"null\"></div><div>最后写段代码来测试下自己的理解：</div><blockquote>console.log(\'1\');\r\n\r\n&nbsp;</blockquote><blockquote><br></blockquote><blockquote>setTimeout(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; console.log(\'2\');\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; process.nextTick(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; console.log(\'3\');\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; })\r\n;</blockquote><blockquote>&nbsp; &nbsp; new Promise(function(resolve) {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; console.log(\'4\');\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; resolve();\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; }).then(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; console.log(\'5\')\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; })\r\n;&nbsp;</blockquote><blockquote>});\r\n&nbsp;</blockquote><blockquote><br></blockquote><blockquote>process.nextTick(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; console.log(\'6\');\r\n&nbsp;</blockquote><blockquote>});\r\n\r\n&nbsp;</blockquote><blockquote><br></blockquote><blockquote>new Promise(function(resolve) {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; console.log(\'7\');\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; resolve();\r\n&nbsp;</blockquote><blockquote>}).then(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; console.log(\'8\')\r\n&nbsp;</blockquote><blockquote>});\r\n\r\n&nbsp;</blockquote><blockquote><br></blockquote><blockquote>setTimeout(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; console.log(\'9\');\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; process.nextTick(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; console.log(\'10\');\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; })\r\n;&nbsp;</blockquote><blockquote>&nbsp; &nbsp; new Promise(function(resolve) {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; console.log(\'11\');\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; &nbsp; &nbsp; resolve();\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; }).then(function() {\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; console.log(\'12\')\r\n&nbsp;</blockquote><blockquote>&nbsp; &nbsp; });</blockquote><blockquote>});<br></blockquote><div><br></div><div>其对应的输出为：</div><blockquote><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">1\r\n7\r\n6\r\n8\r\n2\r\n4\r\n3\r\n5\r\n9\r\n11\r\n10\r\n12</span><br></blockquote><div><br></div><div><br></div><h4>参考链接</h4><div><hr id=\"null\"></div><blockquote><ul><li>https://blog.csdn.net/love2016hy/article/details/80454249</li><li>https://www.cnblogs.com/dong-xu/p/7000163.html<br></li><li>https://www.cnblogs.com/dong-xu/p/7000139.html<br></li><li>https://juejin.im/post/59e85eebf265da430d571f89 <br></li></ul></blockquote></div>'),
(60, 'HTTP缓存机制', '2020-03-15 13:29:21', 'larry·hsu', '<h2>浏览器缓存分类</h2><hr id=\"null\"><div><br></div><div>浏览器缓存可以分为强缓存和协商缓存，浏览器加载一个页面简单流程如下：\r\n \r\n&nbsp;</div><blockquote>1、浏览器根据这个资源的http头信息来判断是否命中缓存，如果命中则直接加载缓存中的资源，并不会将请求发送到服务器。\r\n&nbsp;\r\n<br>2、如果未命中缓存，则浏览器会将资源请求加载发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。\r\n \r\n \r\n&nbsp;<br>3、如果未命中缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新的资源，并更新缓存。\r\n\r\n</blockquote><div><br></div><h4>强缓存</h4><div>命中强缓存时，浏览器并不会将请求发送到服务器。在chrome中，http状态码是200，size中会显示（from cache），强缓存利用的是http头部中的Expires和Cache-Control两个字段来控制的。<br></div><div><b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Expires</span></b><br></div><div>Expire是服务器返回的到期时间，在下一次请求时，请求时间小于这个到期时间，直接使用缓存数据。该字段属于http1.0，但是现在基本都是http1.1，所以基本忽略。有一个缺点是由于到期时间是由服务端生成的，但是客户端和服务器可能有时间误差，将会导致缓存命中的误差。<br></div><div><b><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Cache-Control</span></b><br></div><div>该字段是一个相对时间， 例如Cache-Control:3600，代表着资源的有效期是3600秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。\r\n&nbsp;</div><blockquote>1、max-age：缓存的内容将在xxx秒后失效。\r\n&nbsp;<br>2、public：客户端和代理服务器都可以缓存。\r\n&nbsp;<br>3、private：客户端可以缓存。\r\n&nbsp;<br>4、no-cache： 在使用已缓存的数据前，发送带验证器的请求到服务器。\r\n&nbsp;<br>5、no-store：所有内容都不会缓存。</blockquote><div><br></div><h4>协商缓存</h4><div><b><font color=\"#243c4f\">1、<span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Last-Modify/If-Modefied-Since&nbsp;</span></font></b></div><div>若未命中强缓存，则浏览器会将请求发送到服务器。服务器根据http头信息中的Last-Modefied/ If-Modefied-Since和Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回的状态码为304，浏览器从缓存中加载资源。</div><div><b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">Last-Modify</span>：</font></b>服务器在响应请求时，告诉浏览器资源的最后修改时间。&nbsp;&nbsp;</div><div><b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">If-Modefied-Since</span>：</font></b>该值为缓存之前返回的Last-Modify， 服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</div><div>如果命中缓存，则返回http304，并且不会返回资源内容，也不会返回Last-Modify 。由于对比的服务端时间，所以客户端与服务端的时间差不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了&nbsp;ETag/If-None-Match 。</div><div><br></div><div></div><b><font color=\"#243c4f\">2、<span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">ETag/If-None-Match</span></font></b><div><div></div><div>与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</div><div><b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">ETag</span>：</font></b> 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识。\r\n&nbsp;</div><div><b><font color=\"#243c4f\"><span style=\"color: white; background-color: rgb(36, 60, 79); border-radius: 4px; padding: 2px 4px;\">If-None-Match</span>：</font></b> 再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。<br></div><div><br></div><h2>有了Last-Modefied为何还需要Etag？</h2><hr id=\"null\"><div><br></div><div>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</div><div><blockquote>1、Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。\r\n\r\n&nbsp;<br>2、如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。\r\n\r\n&nbsp;<br>3、有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。</blockquote><div><br></div><div>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。<br></div><div><br></div><div><br></div><h2>参考地址</h2><hr id=\"null\"><br><blockquote>https://www.cnblogs.com/ranyonsue/p/8918908.html<br></blockquote><blockquote>https://www.cnblogs.com/chenqf/p/6386163.html</blockquote></div></div>');

-- --------------------------------------------------------

--
-- 表的结构 `user`
--

CREATE TABLE `user` (
  `id` int(6) NOT NULL,
  `username` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `admin` int(6) NOT NULL DEFAULT '1',
  `nickname` varchar(255) NOT NULL,
  `signature` varchar(100) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

--
-- 转存表中的数据 `user`
--

INSERT INTO `user` (`id`, `username`, `password`, `admin`, `nickname`, `signature`) VALUES
(27, 'larry', 'Mq/+j0MBE3OGYFOUkfPNhQ==', 3, 'larry·hsu', '我很快就要从那一团乱麻中出来了啊！'),
(147, 'hsu', '4QrcOUm6Wau+VuBX8g+IPg==', 2, 'larrytest', '我就要从那一团乱麻中出来了。');

--
-- 转储表的索引
--

--
-- 表的索引 `articles`
--
ALTER TABLE `articles`
  ADD PRIMARY KEY (`id`);

--
-- 表的索引 `user`
--
ALTER TABLE `user`
  ADD PRIMARY KEY (`id`,`nickname`),
  ADD UNIQUE KEY `username` (`username`),
  ADD KEY `nickname` (`nickname`);

--
-- 在导出的表使用AUTO_INCREMENT
--

--
-- 使用表AUTO_INCREMENT `articles`
--
ALTER TABLE `articles`
  MODIFY `id` int(6) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=107;

--
-- 使用表AUTO_INCREMENT `user`
--
ALTER TABLE `user`
  MODIFY `id` int(6) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=162;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
